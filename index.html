
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Raytracer</title>

	<script type="text/javascript" src="javascripts/resources/webgl-utils.js"></script>
	<script language="javascript" src="javascripts/engine/opengl.js" type="text/javascript"></script>
	<script language="javascript" src="javascripts/engine/geometry.js" type="text/javascript"></script>
	<script type="text/javascript" src="javascripts/resources/gl-matrix.js"></script>

  </head>
  <body>
		<div >
			<p>Default -> Experimental <p> <br>
    <canvas style="display:inline-block;" id="canvas" width = "300" height = "300" align="left"></canvas>
    <canvas style="display:inline-block;" id="canvas2" width = "300" height = "300" align="center"></canvas>
	</div>

    Anti-Aliasing<br>
    <form action="">
	<input type="radio" name="AA" value="None" checked onclick="setAntiAliasing(0)">None<br>
	<input type="radio" name="AA" value="2x" onclick="setAntiAliasing(2)">2x<br>
	<input type="radio" name="AA" value="4x" onclick="setAntiAliasing(4)">4x
	</form>

    <script id="shader-fs" type="x-shader/x-fragment">
  		precision highp float;

		uniform vec2 uResolution;

		//constants
		#define MAX_OBJECTS 10
		#define MAX_LIGHTS 10
		#define EPSILON 0.001
		#define MAX_RECURSION 4

		#define MAX_ANTIALIASING 4

		//types of objects as defines
		#define SPHERE 0
		#define PLANE 1


		//the scene as 2d textures
		//the id of objects as well as the type.
		uniform sampler2D objects;
		//the position of the objects a vec4 to allow for one free parameter
		uniform sampler2D objectDefinitions;
		//the materials of the object format to be decided.
		uniform sampler2D objectMaterials;
		//more material properties so that each pixel represents a unique object
		uniform sampler2D objectMaterialsExtended;
		//the light positions
		uniform sampler2D lights;
		//the light colors
		uniform sampler2D lightMaterials;

		//the number of objects in the scene
		uniform int numObjects;
		uniform float objectTextureSize;

		//the level of aliasing
		uniform int antiAliasing;

		uniform int numLights;
		uniform float lightTextureSize;

		//Function to intersect a ray with a sphere
		void iSphere(in vec2 ID, in vec3 origin,in vec3 direction, in vec4 sphere, inout float closestIntersection, inout vec2 closestID)
		{
			//(o + td - c)^2 = r^2
			//(o-c).(o-c) - r^2 + 2t(o-c).d + t^2 = 0
			float b = 2.0*dot(origin-sphere.xyz,direction);
			float c = dot(origin-sphere.xyz,origin-sphere.xyz) - sphere.w*sphere.w;
			float disc = b*b - 4.0*c;

			if(disc < 0.0)
				return;

			float tmp = -(b+sqrt(disc))/2.0;

			if(tmp > 0.0 && tmp < closestIntersection){
				closestIntersection = tmp;
				closestID = ID;
			}
		}

		vec3 nSphere(in vec3 position, in vec4 sphere)
		{
			return normalize(position - sphere.xyz);
		}

		//Function to intersect a ray with a plane
		void iPlane(in vec2 ID, in vec3 origin, in vec3 direction,in vec4 normal,inout float closestIntersection, inout vec2 closestID)
		{
			//(o + td - p0).n = 0 --> (o+td).n = p0.n ---> t = p0.n-
			float tmp = (normal.w-dot(origin,normal.xyz))/dot(direction,normal.xyz);


			if(tmp > 0.0 && tmp < closestIntersection){
				closestIntersection = tmp;
				closestID = ID;
			}
		}

		vec3 nPlane(in vec3 position, in vec4 plane)
		{
			return plane.xyz;
		}

		//function to go through the scene and do all of the ray intersections
		void intersect(in vec3 origin, in vec3 direction,inout float closestIntersection, inout vec2 closestID)
		{
			float it = 1.0/objectTextureSize/2.0;
			float ity = 1.0/objectTextureSize/2.0;

			float step = 1.0/objectTextureSize;

			for(int i = 0  ; i < MAX_OBJECTS ; i++)
			{
				if(i >= numObjects)
					break;

				int objectType = int(texture2D(objects,vec2(it,ity)).y*256.0);

				if(objectType == SPHERE)
					iSphere(vec2(it,ity),origin,direction,texture2D(objectDefinitions,vec2(it,ity)),closestIntersection,closestID);
				else if(objectType ==PLANE)
					iPlane(vec2(it,ity),origin,direction,texture2D(objectDefinitions,vec2(it,ity)),closestIntersection,closestID);

				it+=step;

				if(it > 1.0)
				{
					ity += step;
					it = step/2.0;
				}
			}
		}

		//function to get the normal from an intersection
		vec3 normal(in vec3 position,in vec2 ID)
		{
			if(int(texture2D(objects,ID).y*256.0) == SPHERE)
				return nSphere(position,texture2D(objectDefinitions,ID));
			else if(int(texture2D(objects,ID).y*256.0) == PLANE)
				return nPlane(position,texture2D(objectDefinitions,ID));

			return vec3(0.0,0.0,0.0);
		}

		//function to handle the lighting
		vec4 computeLighting(in vec3 origin, in vec3 direction, in float t, in vec2 ID)
		{
			vec3 intersection = origin + t*direction;
			vec3 norm = normal(intersection,ID);

			vec4 color = vec4(0.01*texture2D(objectMaterials,ID).xyz,1.0);

			float it = 1.0/lightTextureSize/2.0;
			float ity = 1.0/lightTextureSize/2.0;

			float step = 1.0/lightTextureSize;


			//go through each light and add its contribution to the illumination
			for(int i = 0 ; i < MAX_LIGHTS ; i++)
			{
				if(i >= numLights)
					break;

				//if the point can see the light source
				vec3 lightdir = normalize(texture2D(lights,vec2(it,ity)).xyz-intersection);
				vec2 shadowID = vec2(-1.0,-1.0);
				float shadowT = 1000.0;

				intersect(intersection+lightdir*EPSILON,lightdir,shadowT,shadowID);

				if(shadowID.x < 0.0 || shadowT < 0.01){
					//diffuse lighting
					float dp = dot(norm,lightdir);
					if(dp>0.0)
						color += texture2D(objectMaterials,ID).w*dp*vec4(texture2D(objectMaterials,ID).xyz,1.0)*texture2D(lightMaterials,vec2(it,ity));

					//specular lighting
					vec3 R = lightdir - 2.0 * dot(lightdir,norm) * norm;
					dp = dot(direction,R);
					if(dp > 0.0) {
						color += texture2D(objectMaterialsExtended,ID).x * pow(dp,20.0) * vec4(texture2D(lightMaterials,vec2(it,ity)).xyz,1.0);//* vec4(texture2D(objectMaterials,ID).xyz,1.0);
					}
				}

				it+=step;

				if(it > 1.0)
				{
					ity += step;
					it = step/2.0;
				}
			}

			return color;
		}


		vec4 reflection(in vec3 origin, in vec3 direction, in float t, in vec2 ID) {
			vec4 color[MAX_RECURSION];
			float reflCoefficient[MAX_RECURSION];
			vec4 matColor[MAX_RECURSION];

			int recursion = 0;

			for(int i = 0 ; i < MAX_RECURSION ; i++)
			{
				recursion = i;

				vec3 intersection = origin + t*direction;
				vec3 norm = normal(intersection,ID);

				direction = direction - 2.0*dot(direction,norm)*norm;
				origin = intersection + direction * EPSILON;

				vec2 reflID = vec2(-1.0,-1.0);
				float reflT = 1000.0;

				//intersect the reflected ray with the scene
				intersect(origin,direction,reflT,reflID);

				//if we intersected an object
				if(reflID.x < 0.0) {
					color[i] = vec4(0.0,0.0,0.4,1.0);
					reflCoefficient[i] = texture2D(objectMaterialsExtended,ID).y;
					matColor[i] = texture2D(objectMaterials,ID);
					break;
				}

				color[i] = computeLighting(origin,direction,reflT,reflID);
				reflCoefficient[i] = texture2D(objectMaterialsExtended,ID).y;
				matColor[i] = texture2D(objectMaterials,ID);

				if(reflCoefficient[i] < EPSILON)
					break;

				ID = reflID;
				t = reflT;

			}

			vec4 sum = vec4(0.0,0.0,0.0,1.0);

			for(int i = 0 ; i < MAX_RECURSION ; i++)
			{
				if(i > recursion)
					break;

				vec4 prod = vec4(1.0,1.0,1.0,1.0);
				for(int j = 0 ; j < MAX_RECURSION ; j++){
					if(j > i)
						break;

					prod*=reflCoefficient[j]*matColor[j];
				}

				sum+=color[i]*prod;
			}

			return sum;
		}

		//main function
  		void main(void) {
  			gl_FragColor = vec4(0.0,0.0,0.0,0.0);

  			if(antiAliasing < 2)
  			{
  				vec3 origin = vec3(0.0,1.0,-8.0);
				vec3 direction = normalize(vec3((gl_FragCoord.xy/uResolution-0.5)*2.0,1.0));
					float t = 1000.0;
				vec2 ID = vec2(-1.0,-1.0);

				intersect(origin,direction,t,ID);

				//if we intersected with an object
				if(ID.x > 0.0)
				{
					vec4 color = computeLighting(origin,direction,t,ID);

					//if the object is reflective then add a reflective contribution
					if(texture2D(objectMaterialsExtended,ID).y > EPSILON)
						color += reflection(origin,direction,t,ID);

					gl_FragColor += color;

				}else{
					gl_FragColor += vec4(0.0,0.0,0.4,1.0);
				}

  			} else {

				float aa = float(antiAliasing);

				//do antiAliasing
				for(int ax = 0 ; ax < MAX_ANTIALIASING ; ax++)
				{
					if(ax >= antiAliasing)
						break;

					for(int ay =0 ; ay < MAX_ANTIALIASING ; ay++)
					{
						if(ay >= antiAliasing)
							break;

						float fax = float(ax);
						float fay = float(ay);

						vec3 origin = vec3(0.0,1.0,-8.0);
						vec3 direction = normalize(vec3(((gl_FragCoord.xy + vec2((fax - aa/2.0)/aa,(fay - aa/2.0)/aa))/uResolution-0.5)*2.0,1.0));

						float t = 1000.0;
						vec2 ID = vec2(-1.0,-1.0);

						intersect(origin,direction,t,ID);

						//if we intersected with an object
						if(ID.x > 0.0)
						{
							vec4 color = computeLighting(origin,direction,t,ID);

							//if the object is reflective then add a reflective contribution
							if(texture2D(objectMaterialsExtended,ID).y > EPSILON)
								color += reflection(origin,direction,t,ID);

							gl_FragColor += color/aa/aa;

						}else{
							gl_FragColor += vec4(0.0,0.0,0.4,1.0)/aa/aa;
						}
					}
				}
			}
  		}
	</script>

  <script id="shader-fs-lightingImprovement" type="x-shader/x-fragment">
		  	precision highp float;

				uniform vec2 uResolution;

				//constants
				#define MAX_OBJECTS 10
				#define MAX_LIGHTS 10
				#define EPSILON 0.001
				#define MAX_RECURSION 4

				#define MAX_ANTIALIASING 4

				//types of objects as defines
				#define SPHERE 0
				#define PLANE 1


				//the scene as 2d textures
				//the id of objects as well as the type.
				uniform sampler2D objects;
				//the position of the objects a vec4 to allow for one free parameter
				uniform sampler2D objectDefinitions;
				//the materials of the object format to be decided.
				uniform sampler2D objectMaterials;
				//more material properties so that each pixel represents a unique object
				uniform sampler2D objectMaterialsExtended;
				//the light positions
				uniform sampler2D lights;
				//the light colors
				uniform sampler2D lightMaterials;

				//the number of objects in the scene
				uniform int numObjects;
				uniform float objectTextureSize;

				//the level of aliasing
				uniform int antiAliasing;

				uniform int numLights;
				uniform float lightTextureSize;

				//Function to intersect a ray with a sphere
				void iSphere(in vec2 ID, in vec3 origin,in vec3 direction, in vec4 sphere, inout float closestIntersection, inout vec2 closestID)
				{
					//(o + td - c)^2 = r^2
					//(o-c).(o-c) - r^2 + 2t(o-c).d + t^2 = 0
					float b = 2.0*dot(origin-sphere.xyz,direction);
					float c = dot(origin-sphere.xyz,origin-sphere.xyz) - sphere.w*sphere.w;
					float disc = b*b - 4.0*c;

					if(disc < 0.0)
						return;

					float tmp = -(b+sqrt(disc))/2.0;

					if(tmp > 0.0 && tmp < closestIntersection){
						closestIntersection = tmp;
						closestID = ID;
					}
				}

				vec3 nSphere(in vec3 position, in vec4 sphere)
				{
					return normalize(position - sphere.xyz);
				}

				//Function to intersect a ray with a plane
				void iPlane(in vec2 ID, in vec3 origin, in vec3 direction,in vec4 normal,inout float closestIntersection, inout vec2 closestID)
				{
					//(o + td - p0).n = 0 --> (o+td).n = p0.n ---> t = p0.n-
					float tmp = (normal.w-dot(origin,normal.xyz))/dot(direction,normal.xyz);


					if(tmp > 0.0 && tmp < closestIntersection){
						closestIntersection = tmp;
						closestID = ID;
					}
				}

				vec3 nPlane(in vec3 position, in vec4 plane)
				{
					return plane.xyz;
				}

				//function to go through the scene and do all of the ray intersections
				void intersect(in vec3 origin, in vec3 direction,inout float closestIntersection, inout vec2 closestID)
				{
					float it = 1.0/objectTextureSize/2.0;
					float ity = 1.0/objectTextureSize/2.0;

					float step = 1.0/objectTextureSize;

					for(int i = 0  ; i < MAX_OBJECTS ; i++)
					{
						if(i >= numObjects)
							break;

						int objectType = int(texture2D(objects,vec2(it,ity)).y*256.0);

						if(objectType == SPHERE)
							iSphere(vec2(it,ity),origin,direction,texture2D(objectDefinitions,vec2(it,ity)),closestIntersection,closestID);
						else if(objectType ==PLANE)
							iPlane(vec2(it,ity),origin,direction,texture2D(objectDefinitions,vec2(it,ity)),closestIntersection,closestID);

						it+=step;

						if(it > 1.0)
						{
							ity += step;
							it = step/2.0;
						}
					}
				}

				//function to get the normal from an intersection
				vec3 normal(in vec3 position,in vec2 ID)
				{
					if(int(texture2D(objects,ID).y*256.0) == SPHERE)
						return nSphere(position,texture2D(objectDefinitions,ID));
					else if(int(texture2D(objects,ID).y*256.0) == PLANE)
						return nPlane(position,texture2D(objectDefinitions,ID));

					return vec3(0.0,0.0,0.0);
				}

				//function to handle the lighting
				vec4 computeLighting(in vec3 origin, in vec3 direction, in float t, in vec2 ID)
				{	
					vec3 intersection = origin + t*direction;
					vec3 norm = normal(intersection,ID);
					
					norm.x *= cos(gl_FragColor.x);
					norm.y *= sin(gl_FragColor.y);

					vec4 color = vec4(0.01*texture2D(objectMaterials,ID).xyz,1.0);

					float it = 1.0/lightTextureSize/2.0;
					float ity = 1.0/lightTextureSize/2.0;

					float step = 1.0/lightTextureSize;


					//go through each light and add its contribution to the illumination
					for(int i = 0 ; i < MAX_LIGHTS ; i++)
					{
						if(i >= numLights)
							break;

						//if the point can see the light source
						vec3 lightdir = normalize(texture2D(lights,vec2(it,ity)).xyz-intersection);
						vec2 shadowID = vec2(-1.0,-1.0);
						float shadowT = 1000.0;

						intersect(intersection+lightdir*EPSILON,lightdir,shadowT,shadowID);

						if(shadowID.x < 0.0 || shadowT < 0.01){
							//diffuse lighting
							float dp = dot(norm,lightdir);
							if(dp>0.0)
								color += texture2D(objectMaterials,ID).w*dp*vec4(texture2D(objectMaterials,ID).xyz,1.0)*texture2D(lightMaterials,vec2(it,ity));

							//specular lighting
							vec3 R = lightdir - 2.0 * dot(lightdir,norm) * norm;
							dp = dot(direction,R);
							if(dp > 0.0) {
								color += texture2D(objectMaterialsExtended,ID).x * pow(dp,20.0) * vec4(texture2D(lightMaterials,vec2(it,ity)).xyz,1.0);//* vec4(texture2D(objectMaterials,ID).xyz,1.0);
							}

							//color.x +=  cos(gl_FragCoord.x) * sin(gl_FragCoord.x) * .1;
							//color.y +=  sin(gl_FragCoord.y) * cos(gl_FragCoord.x) * .1;
						}

						it+=step;

						if(it > 1.0)
						{
							ity += step;
							it = step/2.0;
						}
					}

					return color;
				}


				vec4 reflection(in vec3 origin, in vec3 direction, in float t, in vec2 ID) {
					vec4 color[MAX_RECURSION];
					float reflCoefficient[MAX_RECURSION];
					vec4 matColor[MAX_RECURSION];

					int recursion = 0;

					for(int i = 0 ; i < MAX_RECURSION ; i++)
					{
						recursion = i;

						vec3 intersection = origin + t*direction;
						vec3 norm = normal(intersection,ID);

						direction = direction - 2.0*dot(direction,norm)*norm;
						origin = intersection + direction * EPSILON;

						vec2 reflID = vec2(-1.0,-1.0);
						float reflT = 1000.0;

						//intersect the reflected ray with the scene
						intersect(origin,direction,reflT,reflID);

						//if we intersected an object
						if(reflID.x < 0.0) {
							color[i] = vec4(0.0,0.0,0.4,1.0);
							reflCoefficient[i] = texture2D(objectMaterialsExtended,ID).y;
							matColor[i] = texture2D(objectMaterials,ID);
							break;
						}

						color[i] = computeLighting(origin,direction,reflT,reflID);
						reflCoefficient[i] = texture2D(objectMaterialsExtended,ID).y;
						matColor[i] = texture2D(objectMaterials,ID);

						if(reflCoefficient[i] < EPSILON)
							break;

						ID = reflID;
						t = reflT;

					}

					vec4 sum = vec4(0.0,0.0,0.0,1.0);

					for(int i = 0 ; i < MAX_RECURSION ; i++)
					{
						if(i > recursion)
							break;

						vec4 prod = vec4(1.0,1.0,1.0,1.0);
						for(int j = 0 ; j < MAX_RECURSION ; j++){
							if(j > i)
								break;

							prod*=reflCoefficient[j]*matColor[j];
						}

						sum+=color[i]*prod;
					}

					return sum;
				}

				//main function
		  		void main(void) {
		  			gl_FragColor = vec4(0.0,0.0,0.0,0.0);

		  			if(antiAliasing < 2)
		  			{
		  				vec3 origin = vec3(0.0,1.0,-8.0);
						vec3 direction = normalize(vec3((gl_FragCoord.xy/uResolution-0.5)*2.0,1.0));
							float t = 1000.0;
						vec2 ID = vec2(-1.0,-1.0);

						intersect(origin,direction,t,ID);

						//if we intersected with an object
						if(ID.x > 0.0)
						{
							vec4 color = computeLighting(origin,direction,t,ID);

							//if the object is reflective then add a reflective contribution
							if(texture2D(objectMaterialsExtended,ID).y > EPSILON)
								color += reflection(origin,direction,t,ID);

							gl_FragColor += color;

						}else{
							gl_FragColor += vec4(0.0,0.0,0.4,1.0);
						}

		  			} else {

						float aa = float(antiAliasing);

						//do antiAliasing
						for(int ax = 0 ; ax < MAX_ANTIALIASING ; ax++)
						{
							if(ax >= antiAliasing)
								break;

							for(int ay =0 ; ay < MAX_ANTIALIASING ; ay++)
							{
								if(ay >= antiAliasing)
									break;

								float fax = float(ax);
								float fay = float(ay);

								vec3 origin = vec3(0.0,1.0,-8.0);
								vec3 direction = normalize(vec3(((gl_FragCoord.xy + vec2((fax - aa/2.0)/aa,(fay - aa/2.0)/aa))/uResolution-0.5)*2.0,1.0));

								float t = 1000.0;
								vec2 ID = vec2(-1.0,-1.0);

								intersect(origin,direction,t,ID);

								//if we intersected with an object
								if(ID.x > 0.0)
								{
									vec4 color = computeLighting(origin,direction,t,ID);

									//if the object is reflective then add a reflective contribution
									if(texture2D(objectMaterialsExtended,ID).y > EPSILON)
										color += reflection(origin,direction,t,ID);

									gl_FragColor += color/aa/aa;

								}else{
									gl_FragColor += vec4(0.0,0.0,0.4,1.0)/aa/aa;
								}
							}
						}
					}
		  		}
			</script>

	<script id="shader-vs" type="x-shader/x-vertex">
	  attribute vec2 aVertexPosition;

	  void main(void) {
		gl_Position = vec4(aVertexPosition, 0.0, 1.0);
	  }
	</script>

	<script type='text/javascript'>
    //<![CDATA[
		var FPS = 60;

		var glCanvas;
		var raytracer;
		//Function to initialize data

		initialize(InitializeWebGL(document.getElementById("canvas"), "shader-vs", "shader-fs" ));
		initialize(InitializeWebGL(document.getElementById("canvas2"), "shader-vs", "shader-fs-lightingImprovement" ));

		//Start the main loop
		tick();

		//Main game loop.
		function tick() {
			requestAnimFrame(tick);
			update();
			draw();
		}

		function initialize(elm)
		{
			if( glCanvas  == undefined )
				glCanvas = [];

			glCanvas[glCanvas.length] = elm;

			_glCanvas = elm;

			if(_glCanvas)
			{
				//Initialize basic attributes
				_glCanvas.clearColor(0.0,0.0,0.0,1.0);
				_glCanvas.enable(glCanvas.DEPTH_TEST);
				_glCanvas.depthFunc(glCanvas.LEQUAL);
				_glCanvas.clear(glCanvas.COLOR_BUFFER_BIT|glCanvas.DEPTH_BUFFER_BIT);

				if( raytracer  == undefined )
					raytracer = [];

				//Initialize the ray tracer
				raytracerNew = new Raytracer(_glCanvas);
				raytracer[raytracer.length] = raytracerNew;
				raytracerNew.build();

				//Add geometry to the scene
				raytracerNew.objects.push(new Sphere());
				raytracerNew.objects[0].position = [0.0,1.01,0.0,1.0];
				raytracerNew.objects[0].material = [0.2,1.0,0.2,0.75];
				raytracerNew.objects[0].materialExtended = [0.3,0.6,0.0,0.0];

				raytracerNew.objects.push(new Sphere());
				raytracerNew.objects[1].position = [2.0,1.01,0.0,1.0];
				raytracerNew.objects[1].material = [0.0,0.0,1.0,0.75];
				raytracerNew.objects[1].materialExtended = [0.3,0.6,0.0,0.0];

				raytracerNew.objects.push(new Sphere());
				raytracerNew.objects[2].position = [-2.0,1.01,0.0,1.0];
				raytracerNew.objects[2].material = [1.0,0.0,0.0,0.75];
				raytracerNew.objects[2].materialExtended = [0.3,0.6,0.0,0.0];

				raytracerNew.objects.push(new Sphere());
				raytracerNew.objects[3].position = [0.0,1.01,2.0,1.0];
				raytracerNew.objects[3].material = [1.0,1.0,0.0,0.75];
				raytracerNew.objects[3].materialExtended = [0.3,0.6,0.0,0.0];

				raytracerNew.objects.push(new Sphere());
				raytracerNew.objects[4].position = [0.0,1.01,2.0,1.0];
				raytracerNew.objects[4].material = [1.0,0.0,1.0,0.75];
				raytracerNew.objects[4].materialExtended = [0.3,0.6,0.0,0.0];

				raytracerNew.objects.push(new Plane());
				raytracerNew.objects[5].position = [0.0,1.0,0.0,0.0];
				raytracerNew.objects[5].material = [0.25,0.25,0.25,1.0];
				raytracerNew.objects[5].materialExtended = [0.0,0.4,0.0,0.0];

				raytracerNew.lights.push(new Light());
				raytracerNew.lights[0].position = [0.0,6.0,-7.0,0.0];
				raytracerNew.lights[0].material = [1.0,1.0,1.0,1.0];

				raytracerNew.lights.push(new Light());
				raytracerNew.lights[1].position = [0.0,6.0,-3.0,0.0];
				raytracerNew.lights[1].material = [1.0,1.0,1.0,1.0];

				//build the geometry
				raytracerNew.buildObjects();
				raytracerNew.buildLights();
			}

			// Camera adjust
			for( var i = 0; i < raytracerNew.objects.length; ++i )
				raytracerNew.objects[i].position.z -= 5.0;

		}

		function setAntiAliasing(a)
		{
			for( var i = 0; i < raytracer.length; ++i )
				raytracer[i].antiAliasing = a;
		}

		//function to update logic
		function update()
		{
		}

		//function to draw to the world
		function draw() {
			if(glCanvas.length){

				for( var i = 0; i < glCanvas.length; ++i )
				{
				//draw the world
				glCanvas[i].viewport(0.0,0.0,glCanvas[i].viewportWidth,glCanvas[i].viewportHeight);

				glCanvas[i].clear(glCanvas[i].COLOR_BUFFER_BIT|glCanvas[i].DEPTH_BUFFER_BIT);

				//update the object positions
				time = new Date().getTime();
				raytracer[i].objects[0].position = [0.0,2.0+Math.sin(0.1*time/1000),-5.0,1.0];
				raytracer[i].objects[1].position = [2.0*Math.cos(time/1000.0),2.0+Math.sin(time/1000),2.0*Math.sin(time/1000.0)-5.0,0.4];
				raytracer[i].objects[2].position = [-2.0*Math.cos(time/1000.0),2.0+Math.sin(time/1000),-2.0*Math.sin(time/1000.0)-5.0,0.4];
				raytracer[i].objects[3].position = [2.0*Math.sin(time/1000.0),2.0+Math.sin(time/1000),-2.0*Math.cos(time/1000.0)-5.0,0.4];
				raytracer[i].objects[4].position = [-2.0*Math.sin(time/1000.0),2.0+Math.sin(time/1000),2.0*Math.cos(time/1000.0)-5.0,0.4];

				//rebuild and draw the scene
				raytracer[i].buildObjects();
				raytracer[i].draw();
			}
			}
		}

	//]]>
    </script>
  </body>
</html>
